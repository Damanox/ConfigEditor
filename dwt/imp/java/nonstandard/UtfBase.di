// D import file generated from 'java\nonstandard\UtfBase.d'
module java.nonstandard.UtfBase;
package const UtfBaseText = "\x0a# line 11 \"java\\nonstandard\\UtfBase.d\"\x0aimport java.lang.util;\x0a\x0aversion(Tango){\x0a    static import tango.text.convert.Utf;\x0a} else { // Phobos\x0a    static import std.utf;\x0a    static import std.conv;\x0a}\x0a\x0a///The Universal Character Set (UCS), defined by the International Standard ISO/IEC 10646\x0a/*typedef*/alias int UCSindex;\x0aalias UCSindex UCSshift;\x0a\x0astatic if(UTFTypeCheck) {\x0a    ///UTF-16 (16-bit Unicode Transformation Format)\x0a    /*struct UTF16index {\x0a        int internalValue;\x0a        alias internalValue val;\x0a        \x0a        private static UTF16index opCall(int _val) {\x0a            UTF16index t = { _val };\x0a            return t;\x0a        }\x0a        \x0a        void opAddAssign(in UTF16shift di) {\x0a            val += di;\x0a        }\x0a        \x0a        void opSubAssign(in UTF16shift di) {\x0a            val -= di;\x0a        }\x0a        \x0amixin(constFuncs!(\"\x0a        UTF16index opAdd(in UTF16shift di) {\x0a            return UTF16index(val + di);\x0a        }\x0a        \x0a        UTF16index opSub(in UTF16shift di) {\x0a            return UTF16index(val - di);\x0a        }\x0a        \x0a        version(Windows) {\x0a            UTF16index opAdd(in int di) {\x0a                return UTF16index(val + di);\x0a            }\x0a            \x0a            UTF16index opSub(in int di) {\x0a                return UTF16index(val - di);\x0a            }\x0a        }\x0a        \x0a        int opCmp(in UTF16index i2) {\x0a            return val - i2.val;\x0a        }\x0a\"));\x0a    }*/\x0a    alias int UTF16index;\x0a    alias int UTF16shift;\x0a\x0a    ///UTF-8 (UCS Transformation Format \xe2\x80\x94 8-bit)\x0a    //typedef int UTF8index;\x0a    //alias UTF8index UTF8shift;\x0a    struct UTF8index {\x0a        int internalValue;\x0a        alias internalValue val;\x0a        \x0a        private static UTF8index opCall(int _val) {\x0a            UTF8index t = { _val };\x0a            return t;\x0a        }\x0a        \x0a        void opAddAssign(in UTF8shift di) {\x0a            val += di.val;\x0a        }\x0a        \x0a        void opSubAssign(in UTF8shift di) {\x0a            val -= di.val;\x0a        }\x0a        \x0amixin(constFuncs!(\"\x0a        UTF8index opAdd(in UTF8shift di) {\x0a            return UTF8index(val + di.val);\x0a        }\x0a        \x0a        UTF8index opSub(in UTF8shift di) {\x0a            return UTF8index(val - di.val);\x0a        }\x0a        \x0a        UTF8shift opSub(in UTF8index di) {\x0a            return UTF8shift(val - di.val);\x0a        }\x0a        \x0a        int opCmp(in UTF8index i2) {\x0a            return val - i2.val;\x0a        }\x0a\"));\x0a    }\x0a    \x0a    private UTF8index newUTF8index(int i) {\x0a        return UTF8index(i);\x0a    }\x0a    \x0a    private int val(T)(T i) {\x0a        static if(is(T : UTF16index))\x0a            return cast(int) i;\x0a        else\x0a            return i.val;\x0a    }\x0a    \x0a    private void dec(ref UTF8index i) {\x0a        --i.val;\x0a    }\x0a    \x0a    struct UTF8shift {\x0a        int internalValue;\x0a        alias internalValue val;\x0a        \x0a        private static UTF8shift opCall(int _val) {\x0a            UTF8shift t = { _val };\x0a            return t;\x0a        }\x0a        \x0a        void opAddAssign(in UTF8shift di) {\x0a            val += di.val;\x0a        }\x0a        \x0a        void opSubAssign(in UTF8shift di) {\x0a            val -= di.val;\x0a        }\x0a        \x0amixin(constFuncs!(\"\x0a        UTF8shift opAdd(in UTF8shift di) {\x0a            return UTF8shift(val + di.val);\x0a        }\x0a        \x0a        UTF8shift opSub(in UTF8shift di) {\x0a            return UTF8shift(val - di.val);\x0a        }\x0a        \x0a        int opCmp(in UTF8shift di2) {\x0a            return val - di2.val;\x0a        }\x0a\"));\x0a    }\x0a    \x0a\x0a    UTF8index asUTF8index(int i) {\x0a        return UTF8index(i);\x0a    }\x0a\x0a    UTF8shift asUTF8shift(int i) {\x0a        return UTF8shift(i);\x0a    }\x0a} else {\x0a    alias int UTF16index;\x0a    alias int UTF16shift;\x0a    \x0a    alias int UTF8index;\x0a    alias int UTF8shift;\x0a    \x0a    private int val(int i) {\x0a        return i;\x0a    }\x0a    \x0a    private void dec(ref UTF8index i) {\x0a        --i;\x0a    }\x0a}\x0a\x0achar charByteAt(in char[] s, in UTF8index i) {\x0a    return s[val(i)];\x0a}\x0a\x0aUTF8index preFirstIndex(in char[] s) {\x0a    return cast(UTF8index) -1;\x0a}\x0a\x0aUTF8index firstIndex(in char[] s) {\x0a    return cast(UTF8index) 0;\x0a}\x0a\x0aUTF8index endIndex(in char[] s) {\x0a    return cast(UTF8index) s.length;\x0a}\x0a\x0aUTF8index beforeEndIndex(in char[] s) {\x0a    return s.offsetBefore(s.endIndex());\x0a}\x0a\x0a\x0a//These variables aren't in TLS so it can be used only for writing\x0amixin(gshared!(\"\x0aprivate UCSindex UCSdummyShift;\x0aprivate UTF8shift UTF8dummyShift;\x0aprivate UTF16shift UTF16dummyShift;\x0a\"));\x0a\x0aprivate const ubyte[256] p_UTF8stride =\x0a[\x0a    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\x0a    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\x0a    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\x0a    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\x0a    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\x0a    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\x0a    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\x0a    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\x0a    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\x0a    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\x0a    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\x0a    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\x0a    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\x0a    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\x0a    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\x0a    4,4,4,4,4,4,4,4,5,5,5,5,6,6,0xFF,0xFF,\x0a];\x0a\x0aprivate String toUTF8infoString(in char[] s, UTF8index i) {\x0a    return Format(\"i = {}, s[i] = {}, s = {}\", val(i), cast(ubyte)s.charByteAt(i), cast(ubyte[])s);\x0a}\x0a\x0aclass UTF8Exception : Exception {\x0a    this( String msg, in char[] s, UTF8index i){\x0a        super( Format(\"{}:\\n{}\", msg, toUTF8infoString(s, i)));\x0a    }\x0a}\x0a\x0abool isUTF8sequenceStart( in char[] s, in UTF8index i ) {\x0a    return p_UTF8stride[s.charByteAt(i)] != 0xFF;\x0a}\x0a\x0avoid validateUTF8index( in char[] s, in UTF8index i ) {\x0a    if(i != s.endIndex() && !s.isUTF8sequenceStart(i))\x0a        throw new UTF8Exception(\"Not a start of an UTF-8 sequence\", s, i);\x0a}\x0a\x0aUTF8shift UTF8strideAt( in char[] s, in UTF8index i ) {\x0a    s.validateUTF8index(i);\x0a    version(Tango) {\x0a        return cast(UTF8shift)p_UTF8stride[s.charByteAt(i)];\x0a    } else { // Phobos\x0a        return cast(UTF8shift)std.utf.stride( s, val(i) );\x0a    }\x0a}\x0a\x0aUTF16shift UTF16strideAt( in wchar[] s, in UTF16index i ) {\x0a    //s.validateUTF16index(i);\x0a    version(Tango) {\x0a        uint u = s[val(i)];\x0a        return cast(UTF16shift)(1 + (u >= 0xD800 && u <= 0xDBFF));\x0a    } else { // Phobos\x0a        return cast(UTF16shift)std.utf.stride( s, val(i) );\x0a    }\x0a}\x0a\x0aUCSindex UCScount( in char[] s ){\x0a    version(Tango){\x0a        scope dchar[] buf = new dchar[]( s.length );\x0a        uint ate;\x0a        dchar[] res = tango.text.convert.Utf.toString32( s, buf, &ate );\x0a        assert( ate is s.length );\x0a        return res.length;\x0a    } else { // Phobos\x0a        return std.utf.count(s);\x0a    }\x0a}\x0a\x0aUTF8shift toUTF8shift( in char[] s, in UTF8index i, in UCSshift dn ) {\x0a    s.validateUTF8index(i);\x0a    UTF8index j = i;\x0a    UCSshift tdn = dn;\x0a    if(tdn > 0) {\x0a        do {\x0a            j += s.UTF8strideAt(j);\x0a            if(j > s.endIndex()) {\x0a                throw new UTF8Exception(Format(\"toUTF8shift (dn = {}): No end of the UTF-8 sequence\", dn), s, i);\x0a            }\x0a        } while(--tdn);\x0a    } else if(tdn < 0) {\x0a        do {\x0a            if(!val(j)) {\x0a                if(tdn == -1) {\x0a                    j = s.preFirstIndex();\x0a                    break;\x0a                } else {\x0a                    throw new UTF8Exception(Format(\"toUTF8shift (dn = {}): Can only go down to -1, not {}\", dn, tdn), s, i);\x0a                }\x0a            }\x0a            int l = 0;\x0a            do {\x0a                if(!val(j)) {\x0a                    throw new UTF8Exception(Format(\"toUTF8shift (dn = {}): No start of the UTF-8 sequence before\", dn), s, i);\x0a                }\x0a                ++l;\x0a                dec(j);\x0a            } while(!s.isUTF8sequenceStart(j));\x0a            l -= val(s.UTF8strideAt(j));\x0a            if(l > 0) {\x0a                throw new UTF8Exception(Format(\"toUTF8shift (dn = {}): Overlong UTF-8 sequence before\", dn), s, i);\x0a            } else if(l < 0) {\x0a                throw new UTF8Exception(Format(\"toUTF8shift (dn = {}): Too short UTF-8 sequence before\", dn), s, i);\x0a            }\x0a        } while(++tdn);\x0a    }\x0a    return j - i;\x0a}\x0a\x0aUTF8index offsetBefore( in char[] s, in UTF8index i ) {\x0a   return i + s.toUTF8shift(i, -1);\x0a}\x0a\x0aUTF8index offsetAfter( in char[] s, in UTF8index i ) {\x0a   return i + s.toUTF8shift(i, 1);\x0a}\x0a\x0a/**\x0aIf the index is in a midle of an UTF-8 byte sequence, it\x0awill return the position of the first byte of this sequence.\x0a*/\x0avoid adjustUTF8index( in char[] s, ref UTF8index i ){\x0a    if(i == s.endIndex() || s.isUTF8sequenceStart(i))\x0a        return;\x0a    \x0a    int l = 0;\x0a    alias i res;\x0a    do {\x0a        if(!val(res))\x0a            throw new UTF8Exception(\"adjustUTF8index: No start of the UTF-8 sequence\", s, i);\x0a        ++l;\x0a        dec(res);\x0a    } while(!s.isUTF8sequenceStart(res));\x0a    l -= val(s.UTF8strideAt(i));\x0a    if(l > 0)\x0a        throw new UTF8Exception(\"adjustUTF8index: Overlong UTF-8 sequence\", s, i);\x0a}\x0a\x0aUTF8index takeIndexArg(String F = __FILE__, uint L = __LINE__)(String s, int i_arg, String location) {\x0a    UTF8index res = cast(UTF8index) i_arg;\x0a    if(i_arg > 0 && i_arg < s.length) {\x0a        auto t = res;\x0a        s.adjustUTF8index(res);\x0a        if(t != res)\x0a            getDwtLogger().warn(F, L, Format(\"Fixed invalid UTF-8 index at {}:\\nnew i = {}, {}\", location, val(res), toUTF8infoString(s, t)));\x0a    }\x0a    return res;\x0a}\x0a\x0adchar dcharAt( in char[] s, in UTF8index i, out UTF8shift stride = UTF8dummyShift ) {\x0a    s.validateUTF8index(i);\x0a    auto str = s[val(i) .. $];\x0a    version(Tango){\x0a        dchar[1] buf;\x0a        uint ate;\x0a        dchar[] res = tango.text.convert.Utf.toString32( str, buf, &ate );\x0a        assert( ate > 0 && res.length is 1 );\x0a        stride = cast(UTF8shift)ate;\x0a        return res[0];\x0a    } else { // Phobos\x0a        size_t ate = 0;\x0a        dchar res = std.utf.decode(str, ate);\x0a        stride = cast(UTF8shift)ate;\x0a        return res;\x0a    }\x0a}\x0a\x0adchar dcharAt( in wchar[] s, in UTF16index i, out UTF16shift stride = UTF16dummyShift ) {\x0a    //s.validateUTF16index(i);\x0a    auto str = s[val(i) .. $];\x0a    version(Tango){\x0a        dchar[1] buf;\x0a        uint ate;\x0a        dchar[] res = tango.text.convert.Utf.toString32( str, buf, &ate );\x0a        assert( ate > 0 && res.length is 1 );\x0a        stride = cast(UTF16shift)ate;\x0a        if( ate is 0 || res.length is 0 ){\x0a            getDwtLogger().trace( __FILE__, __LINE__, \"str.length={} str={:X2}\", str.length, cast(ubyte[])str );\x0a        }\x0a        return res[0];\x0a    } else { // Phobos\x0a        size_t ate = 0;\x0a        dchar res = std.utf.decode(str, ate);\x0a        stride = cast(UTF16shift)ate;\x0a        return res;\x0a    }\x0a}\x0a\x0adchar dcharBefore( in char[] s, in UTF8index i ) {\x0a   return s.dcharAt(s.offsetBefore(i));\x0a}\x0a\x0adchar dcharAfter( in char[] s, in UTF8index i ) {\x0a    return s.dcharAt(i + s.toUTF8shift(i, 1));\x0a}\x0a\x0a///Get that String, that contains the next codepoint of a String.\x0aString dcharAsStringAt( in char[] s, in UTF8index i, out UTF8shift stride = UTF8dummyShift ) {\x0a    s.validateUTF8index(i);\x0a    auto str = s[val(i) .. $];\x0a    uint ate;\x0a    version(Tango){\x0a        dchar[1] buf;\x0a        dchar[] res = tango.text.convert.Utf.toString32( str, buf, &ate );\x0a    } else { // Phobos\x0a        ate = std.utf.stride( str, 0 );\x0a    }\x0a    stride = cast(UTF8shift)ate;\x0a    return str[ 0 .. ate ]._idup();\x0a}\x0a\x0a";

